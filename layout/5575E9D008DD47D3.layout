<?xml version="1.0" encoding="utf-8" ?>
<library version="20131122">
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="TransformNormal">
    <desc>
    This fragment is responsible for applying the world transform to the
    normal.
    </desc>
    <inputs>
        <resource type="float3" variable="Normal" />
        <resource type="float4x4" variable="World" />
    </inputs>
    <outputs>
        <resource type="float3" variable="WorldNrm" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    // Transform the normal into world space for lighting
    WorldNrm = mul( Normal, (float3x3)World );

    // Should not need to normalize here since we will normalize in the pixel 
    // shader due to linear interpolation across triangle not preserving
    // normality.
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="TransformNBT">
    <desc>
    This fragment is responsible for applying the world transform to the
    normal, binormal, and tangent.
    </desc>
    <inputs>
        <resource type="float3" variable="Normal" />
        <resource type="float3" variable="Binormal" />
        <resource type="float3" variable="Tangent" />
        <resource type="float4x4" variable="World" />
    </inputs>
    <outputs>
        <resource type="float3" variable="WorldNrm" />
        <resource type="float3" variable="WorldBinormal" />
        <resource type="float3" variable="WorldTangent" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    // Transform the normal into world space for lighting
    WorldNrm      = mul( Normal, (float3x3)World );
    WorldBinormal = mul( Binormal, (float3x3)World );
    WorldTangent  = mul( Tangent, (float3x3)World );
    
    // Should not need to normalize here since we will normalize in the pixel 
    // shader due to linear interpolation across triangle not preserving
    // normality.
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="TransformPosition">
    <desc>
    This fragment is responsible for applying the view projection transform
    to the input position. Additionally, this fragment applies the world 
    transform to the input position. 
    </desc>
    <inputs>
        <resource type="float3" variable="Position" />
        <resource type="float4x4" variable="World" />
    </inputs>
    <outputs>
        <resource type="float4" variable="WorldPos" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    // Transform the position into world space for lighting, and projected 
    // space for display
    WorldPos = mul( float4(Position, 1.0), World );
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="WorldToTangent">
    <desc>
    This fragment is responsible for transforming a vector from world space
    to tangent space.
    </desc>
    <inputs>
        <resource type="float3" variable="VectorIn" />
        <resource type="float3" variable="WorldNormalIn" />
        <resource type="float3" variable="WorldBinormalIn" />
        <resource type="float3" variable="WorldTangentIn" />
    </inputs>
    <outputs>
        <resource type="float3" variable="VectorOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    float3x3 xForm = float3x3(WorldTangentIn, WorldBinormalIn, WorldNormalIn);
    VectorOut = mul(xForm, VectorIn.xyz);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="TransformSkinnedPosition">
    <desc>
    This fragment is responsible for applying the view projection and skinning 
    transform to the input position. Additionally, this fragment applies the 
    computed world transform to the input position. The weighted world 
    transform defined by the blendweights is output for use in normals or
    other calculations as the new world matrix.
    </desc>
    <inputs>
        <resource type="float3" variable="Position" />
        <resource type="int4" variable="BlendIndices" />
        <resource type="float3" variable="BlendWeights" />
        <resource type="float4x3" variable="Bones" count="30" />
    </inputs>
    <outputs>
        <resource type="float4" variable="WorldPos" />
        <resource type="float4x4" variable="SkinBoneTransform" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    // TransformSkinnedPosition *********************************************
    // Transform the skinned position into world space
    // Composite the skinning transform which will take the vertex
    // and normal to world space.
    float fWeight3 = 1.0 - BlendWeights[0] - BlendWeights[1] - BlendWeights[2];
    float4x3 ShortSkinBoneTransform;
    ShortSkinBoneTransform  = Bones[BlendIndices[0]] * BlendWeights[0];
    ShortSkinBoneTransform += Bones[BlendIndices[1]] * BlendWeights[1];
    ShortSkinBoneTransform += Bones[BlendIndices[2]] * BlendWeights[2];
    ShortSkinBoneTransform += Bones[BlendIndices[3]] * fWeight3;
    SkinBoneTransform = float4x4(ShortSkinBoneTransform[0], 0.0, 
        ShortSkinBoneTransform[1], 0.0, 
        ShortSkinBoneTransform[2], 0.0, 
        ShortSkinBoneTransform[3], 1.0);

    // Transform into world space.
    WorldPos.xyz = mul(float4(Position, 1.0), ShortSkinBoneTransform);
    WorldPos.w = 1.0;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="TransformSkinnedPositionNoIndices">
    <desc>
    This fragment is responsible for applying the view projection and skinning 
    transform to the input position. Additionally, this fragment applies the 
    computed world transform to the input position. The weighted world 
    transform defined by the blendweights is output for use in normals or
    other calculations as the new world matrix.
    </desc>
    <inputs>
        <resource type="float3" variable="Position" />
        <resource type="float3" variable="BlendWeights" />
        <resource type="float4x3" variable="Bones" count="4" />
    </inputs>
    <outputs>
        <resource type="float4" variable="WorldPos" />
        <resource type="float4x4" variable="SkinBoneTransform" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    // TransformSkinnedPosition *********************************************
    // Transform the skinned position into world space
    // Composite the skinning transform which will take the vertex
    // and normal to world space.
    float fWeight3 = 1.0 - BlendWeights[0] - BlendWeights[1] - BlendWeights[2];
    float4x3 ShortSkinBoneTransform;
    ShortSkinBoneTransform  = Bones[0] * BlendWeights[0];
    ShortSkinBoneTransform += Bones[1] * BlendWeights[1];
    ShortSkinBoneTransform += Bones[2] * BlendWeights[2];
    ShortSkinBoneTransform += Bones[3] * fWeight3;
    SkinBoneTransform = float4x4(ShortSkinBoneTransform[0], 0.0, 
        ShortSkinBoneTransform[1], 0.0, 
        ShortSkinBoneTransform[2], 0.0, 
        ShortSkinBoneTransform[3], 1.0);

    // Transform into world space.
    WorldPos.xyz = mul(float4(Position, 1.0), ShortSkinBoneTransform);
    WorldPos.w = 1.0;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="ProjectPositionWorldToProj">
    <desc>
    This fragment is responsible for applying the view projection transform
    to the input world position.
    </desc>
    <inputs>
        <resource type="float4" variable="WorldPosition" />
        <resource type="float4x4" variable="ViewProjection" />
    </inputs>
    <outputs>
        <resource type="float4" variable="ProjPos" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    ProjPos = mul(WorldPosition, ViewProjection);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="ProjectPositionWorldToViewToProj">
    <desc>
    This fragment is responsible for applying the view projection transform
    to the input world position.
    </desc>
    <inputs>
        <resource type="float4" variable="WorldPosition" />
        <resource type="float4x4" variable="ViewTransform" />
        <resource type="float4x4" variable="ProjTransform" />
    </inputs>
    <outputs>
        <resource type="float4" variable="ViewPos" />
        <resource type="float4" variable="ProjPos" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    ViewPos = mul(WorldPosition, ViewTransform);
    ProjPos = mul(ViewPos, ProjTransform);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="9thOrderSphericalHarmonicLighting">
    <desc>
    This fragment is responsible for generating the diffuse 
    lighting environment as compressed in spherical harmonics.
    </desc>
    <inputs>
        <resource type="float3" variable="WorldNormal" />
        <resource type="float3" variable="SHCoefficients" count="9" />
    </inputs>
    <outputs>
        <resource type="float4" variable="DiffuseColorOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    DiffuseColorOut  = SHCoefficients[0];
    DiffuseColorOut += SHCoefficients[1] * WorldNormal.x;
    DiffuseColorOut += SHCoefficients[2] * WorldNormal.y;
    DiffuseColorOut += SHCoefficients[3] * WorldNormal.z;
    DiffuseColorOut += SHCoefficients[4] * WorldNormal.x * WorldNormal.z;
    DiffuseColorOut += SHCoefficients[5] * WorldNormal.y * WorldNormal.z;
    DiffuseColorOut += SHCoefficients[6] * WorldNormal.x * WorldNormal.y;
    DiffuseColorOut += SHCoefficients[7] * (3.0 * WorldNormal.z * WorldNormal.z  - 1.0);
    DiffuseColorOut += SHCoefficients[8] * (WorldNormal.x * WorldNormal.x  - WorldNormal.y * WorldNormal.y);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel" name="CalculateNormalFromColor">
    <desc>
    This fragment is responsible for sampling a normal map to generate the
    new world-space normal.
    
    The normal map type is an enumerated value that indicates the following:
        0 - Standard (rgb = normal/binormal/tangent)
        1 - DXN (rg = normal.xy need to calculate z)
        2 - DXT5 (ag = normal.xy need to calculate z)
    </desc>
    <inputs>
        <resource type="float4" variable="NormalMap" />
        <resource type="float3" variable="WorldNormalIn" />
        <resource type="float3" variable="WorldBinormalIn" />
        <resource type="float3" variable="WorldTangentIn" />
        <resource type="int" variable="NormalMapType" default="(0)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="WorldNormalOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="ps_2_0/vs_3_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    NormalMap = NormalMap * 2.0 - 1.0;
    
    // Do nothing extra for Standard
    // Handle compressed types:
    if (NormalMapType == 1) // DXN
    {
        NormalMap.rgb = float3(NormalMap.r, NormalMap.g, sqrt(1 - NormalMap.r * NormalMap.r - NormalMap.g * NormalMap.g));
    }
    else if (NormalMapType == 2) // DXT5
    {
        NormalMap.rg = NormalMap.ag;
        NormalMap.b = sqrt(1 - NormalMap.r*NormalMap.r - NormalMap.g * NormalMap.g);
    }
       
    float3x3 xForm = float3x3(WorldTangentIn, WorldBinormalIn, WorldNormalIn);
    xForm = transpose(xForm);
    WorldNormalOut = mul(xForm, NormalMap.rgb);
    
    WorldNormalOut = normalize(WorldNormalOut);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel" name="CalculateParallaxOffset">
    <desc>
    This fragment is responsible for calculating the UV offset to apply
    as a result of a parallax map.
    </desc>
    <inputs>
        <resource type="float2" variable="TexCoord" />
        <resource type="float2" variable="Height" />
        <resource type="float" variable="OffsetScale" default="(0.05)" />
        <resource type="float3" variable="TangentSpaceEyeVec" default="(1.0, 0.0, 0.0)" />
    </inputs>
    <outputs>
        <resource type="float2" variable="ParallaxOffsetUV" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="ps_2_0/vs_3_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    // Calculate offset scaling constant bias.
    float2 Bias = float2(OffsetScale, OffsetScale) * -0.5;

    // Calculate offset
    float2 Offset = Height.rg * OffsetScale + Bias;

    // Get texcoord.
    ParallaxOffsetUV = TexCoord + Offset * TangentSpaceEyeVec.xy;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel" name="CalculateBumpOffset">
    <desc>
    This fragment is responsible for calculating the UV offset to apply
    as a result of a bump map.
    </desc>
    <inputs>
        <resource type="float2" variable="DuDv" />
        <resource type="float4" variable="BumpMatrix" default="(1.0, 1.0, 1.0, 1.0)" />
    </inputs>
    <outputs>
        <resource type="float2" variable="BumpOffset" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="ps_2_0/vs_3_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    BumpOffset.x = DuDv.x * BumpMatrix[0] + DuDv.y * BumpMatrix[2];
    BumpOffset.y = DuDv.x * BumpMatrix[1] + DuDv.y * BumpMatrix[3];
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="OffsetUVFloat2">
    <desc>
    This fragment is responsible for applying a UV offset to a texture
    coordinate set.
    </desc>
    <inputs>
        <resource type="float2" variable="TexCoordIn" />
        <resource type="float2" variable="TexCoordOffset" />
    </inputs>
    <outputs>
        <resource type="float2" variable="TexCoordOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    TexCoordOut = TexCoordIn + TexCoordOffset;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="OffsetUVFloat3">
    <desc>
    This fragment is responsible for applying a UV offset to a texture
    coordinate set.
    </desc>
    <inputs>
        <resource type="float3" variable="TexCoordIn" />
        <resource type="float2" variable="TexCoordOffset" />
    </inputs>
    <outputs>
        <resource type="float3" variable="TexCoordOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    TexCoordOut = TexCoordIn + float3(TexCoordOffset.x, TexCoordOffset.y, 0.0);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="OffsetUVFloat4">
    <desc>
    This fragment is responsible for applying a UV offset to a texture
    coordinate set.
    </desc>
    <inputs>
        <resource type="float4" variable="TexCoordIn" />
        <resource type="float2" variable="TexCoordOffset" />
    </inputs>
    <outputs>
        <resource type="float4" variable="TexCoordOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    TexCoordOut = TexCoordIn + 
        float4(TexCoordOffset.x, TexCoordOffset.y, 0.0, 0.0);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="TexTransformApply">
    <desc>
    This fragment is responsible for applying a transform to the input set
    of texture coordinates.
    </desc>
    <inputs>
        <resource type="float2" variable="TexCoord" />
        <resource type="float4x4" variable="TexTransform" />
    </inputs>
    <outputs>
        <resource type="float2" variable="TexCoordOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    TexCoordOut = mul(float4(TexCoord.x, TexCoord.y, 0.0, 1.0), TexTransform);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="ProjectTextureCoordinates">
    <desc>
    This fragment is responsible for applying a projection to the input set
    of texture coordinates.
    </desc>
    <inputs>
        <resource type="float3" variable="TexCoord" />
        <resource type="float4x4" variable="TexTransform" />
    </inputs>
    <outputs>
        <resource type="float4" variable="TexCoordOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    TexCoordOut = mul(float4(TexCoord, 1.0), TexTransform);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel" name="TextureRGBSample">
    <desc>
    This fragment is responsible for sampling a texture and returning its value
    as a RGB value.
    </desc>
    <inputs>
        <resource type="float2" variable="TexCoord" />
        <resource type="sampler2D" variable="Texture" />
        <resource type="sampler" variable="Sampler" />
        <resource type="bool" variable="Saturate" default="(true)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="ColorOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="DX9/Xenon/PS3" target="ps_2_0">
    ColorOut.rgb = tex2D(Texture, TexCoord).rgb;
    if (Saturate)
    {
        ColorOut.rgb = saturate(ColorOut.rgb);
    }
    </code>
    <code lang="hlsl/Cg" platform="D3D11/D3D10" target="ps_4_0">
    ColorOut.rgb = Texture.Sample(Sampler, TexCoord).rgb;
    if (Saturate)
    {
        ColorOut.rgb = saturate(ColorOut.rgb);
    }
    </code>
    <code lang="hlsl/Cg" platform="D3D11/D3D10" target="vs_4_0/gs_4_0/hs_5_0/ds_5_0">
    ColorOut.rgb = Texture.SampleLevel(Sampler, TexCoord, 0).rgb;
    if (Saturate)
    {
        ColorOut.rgb = saturate(ColorOut.rgb);
    }
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel" name="TextureRGBASample">
    <desc>
    This fragment is responsible for sampling a texture and returning its value
    as a RGB value and an A value.
    </desc>
    <inputs>
        <resource type="float2" variable="TexCoord" />
        <resource type="sampler2D" variable="Texture" />
        <resource type="sampler" variable="Sampler" />
        <resource type="bool" variable="Saturate" default="(true)" />
    </inputs>
    <outputs>
        <resource type="float4" variable="ColorOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="DX9/Xenon/PS3" target="ps_2_0">
    ColorOut = tex2D(Texture, TexCoord);
    if (Saturate)
    {
        ColorOut = saturate(ColorOut);
    }
    </code>
    <code lang="hlsl/Cg" platform="D3D11/D3D10" target="ps_4_0">
    ColorOut = Texture.Sample(Sampler, TexCoord);
    if (Saturate)
    {
        ColorOut = saturate(ColorOut);
    }
    </code>
    <code lang="hlsl/Cg" platform="D3D11/D3D10" target="vs_4_0/gs_4_0/hs_5_0/ds_5_0">
    ColorOut = Texture.SampleLevel(Sampler, TexCoord, 0);
    if (Saturate)
    {
        ColorOut = saturate(ColorOut);
    }
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel" name="TextureRGBProjectSample">
    <desc>
    This fragment is responsible for sampling a texture and returning its value
    as a RGB value and an A value.
    </desc>
    <inputs>
        <resource type="float3" variable="TexCoord" />
        <resource type="sampler2D" variable="Texture" />
        <resource type="sampler" variable="Sampler" />
        <resource type="bool" variable="Saturate" default="(true)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="ColorOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="DX9/Xenon/PS3" target="ps_2_0">
    float4 ProjTexCoord = TexCoord.xyzz;
    ColorOut.rgb = tex2Dproj(Texture, ProjTexCoord).rgb;
    if (Saturate)
    {
        ColorOut.rgb = saturate(ColorOut.rgb);
    }
    </code>
    <code lang="hlsl/Cg" platform="D3D11/D3D10" target="vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    float2 ProjTexCoord = TexCoord.xy / TexCoord.z;
    ColorOut.rgb = Texture.Sample(Sampler, ProjTexCoord).rgb;
    if (Saturate)
    {
        ColorOut.rgb = saturate(ColorOut.rgb);
    }
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel" name="TextureRGBCubeSample">
    <desc>
    This fragment is responsible for sampling a texture and returning its value
    as a RGB value.
    </desc>
    <inputs>
        <resource type="float3" variable="TexCoord" />
        <resource type="samplerCUBE" variable="Texture" />
        <resource type="sampler" variable="Sampler" />
        <resource type="bool" variable="Saturate" default="(true)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="ColorOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="DX9/Xenon/PS3" target="ps_2_0">
    ColorOut.rgb = texCUBE(Texture, TexCoord).rgb;
    if (Saturate)
    {
        ColorOut.rgb = saturate(ColorOut.rgb);
    }
    </code>
    <code lang="hlsl/Cg" platform="D3D11/D3D10" target="vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    ColorOut.rgb = Texture.Sample(Sampler, TexCoord).rgb;
    if (Saturate)
    {
        ColorOut.rgb = saturate(ColorOut.rgb);
    }
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="CalculateFog">
    <desc>
    This fragment is responsible for handling fogging calculations.
    FogType can be one of 4 values:
    
        NONE   - 0
        EXP    - 1
        EXP2   - 2
        LINEAR - 3
    </desc>
    <inputs>
        <resource type="int" variable="FogType" />
        <resource type="float" variable="FogDensity" default="(1.0)" />
        <resource type="float4" variable="ViewPosition" default="(0.0, 0.0, 0.0, 0.0)" />
        <resource type="bool" variable="FogRange" default="(false)" />
        <resource type="float2" variable="FogStartEnd" default="(0.0, 1.0)" />
    </inputs>
    <outputs>
        <resource type="float" variable="FogOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    float d;
    if (FogRange)
    {
        d = length(ViewPosition);
    }
    else
    {
        d = ViewPosition.z;
    }
    
    if (FogType == 0) // NONE
    {
        FogOut = 1.0;
    }
    else if (FogType == 1) // EXP
    {
        FogOut = 1.0 / exp( d * FogDensity);
    }
    else if (FogType == 2) // EXP2
    {
        FogOut = 1.0 / exp( pow( d * FogDensity, 2));
    }
    else if (FogType == 3) // LINEAR
    {
        FogOut = saturate( (FogStartEnd.y - d) / (FogStartEnd.y - FogStartEnd.x));
    }
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="WorldReflect">
    <desc>
    This fragment is responsible for computing the reflection vector.
    The WorldViewVector is negated because the HLSL "reflect" function
    expects a world-to-camera vector, rather than a camera-to-world vector.
    </desc>
    <inputs>
        <resource type="float3" variable="WorldNrm" />
        <resource type="float3" variable="WorldViewVector" />
        <resource type="bool" variable="NormalizeNormal" default="(true)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="WorldReflect" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    if (NormalizeNormal)
        WorldNrm = normalize(WorldNrm);
    WorldReflect = reflect(-WorldViewVector, WorldNrm);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="CalculateViewVector">
    <desc>
    This fragment is responsible for calculating the camera view vector.
    </desc>
    <inputs>
        <resource type="float4" variable="WorldPos" />
        <resource type="float3" variable="CameraPos" default="(0.0, 0.0, 0.0)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="WorldViewVector" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    WorldViewVector = CameraPos - WorldPos;
    </code>
</fragment>   
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="ClippingPlaneTest">
    <desc>
    This fragment is responsible for calculating whether or not the current
    position is on the positive or negative side of a clipping plane. If the
    point is on the positive side, the return value will be 1.0. If the value 
    is on the negative side, the return value will be 0.0. If the point is on
    the plane, the return value will be 0.0. If InvertClip is true, then the
    fragment returns the opposite of the above.
    
    A plane is assumed to be the points X satisfying the expression:
        X * normal = plane_constant
        
    The WorldClipPlane must match the form of NiPlane, which is of the form:
        (normal.x, normal.y, normal.z, plane_constant)
    </desc>
    <inputs>
        <resource type="float4" variable="WorldPos" />
        <resource type="float4" variable="WorldClipPlane" default="(1.0, 0.0, 0.0, 0.0)" />
        <resource type="bool" variable="InvertClip" default="(false)" />
    </inputs>
    <outputs>
        <resource type="float" variable="Scalar" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    float fDistance = dot(WorldClipPlane.xyz, WorldPos.xyz) - WorldClipPlane.w;
    if (InvertClip)
        Scalar = fDistance &gt; 0.0 ? 0.0 : 1.0;
    else
        Scalar = fDistance &gt; 0.0 ? 1.0 : 0.0;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="Light">
    <desc>
    This fragment is responsible for accumulating the effect of a light
    on the current pixel.
    
    LightType can be one of three values:
        0 - Directional
        1 - Point 
        2 - Spot
        
    Note that the LightType must be a compile-time variable,
    not a runtime constant/uniform variable on most Shader Model 2.0 cards.
    
    The compiler will optimize out any constants that aren't used.
    
    Attenuation is defined as (const, linear, quad, range).
    Range is not implemented at this time.
    
    SpotAttenuation is stored as (cos(theta/2), cos(phi/2), falloff)
    theta is the angle of the inner cone and phi is the angle of the outer
    cone in the traditional DX manner. Gamebryo only allows setting of
    phi, so cos(theta/2) will typically be cos(0) or 1. To disable spot
    effects entirely, set cos(theta/2) and cos(phi/2) to -1 or lower.
    </desc>
    <inputs>
        <resource type="float4" variable="WorldPos" />
        <resource type="float3" variable="WorldNrm" />
        <resource type="int" variable="LightType" default="(0)" />
        <resource type="bool" variable="SpecularEnable" default="(false)" />
        <resource type="float" variable="Shadow" default="(1.0)" />
        <resource type="float3" variable="WorldViewVector" default="(0.0, 0.0, 0.0)" />
        <resource type="float4" variable="LightPos" default="(0.0, 0.0, 0.0, 0.0)" />
        <resource type="float3" variable="LightAmbient" default="(1.0, 1.0, 1.0)" />
        <resource type="float3" variable="LightDiffuse" default="(1.0, 1.0, 1.0)" />
        <resource type="float3" variable="LightSpecular" default="(1.0, 1.0, 1.0)" />
        <resource type="float3" variable="LightAttenuation" default="(0.0, 1.0, 0.0)" />
        <resource type="float3" variable="LightSpotAttenuation" default="(-1.0, -1.0, 0.0)" />
        <resource type="float3" variable="LightDirection" default="(1.0, 0.0, 0.0)" />
        <resource type="float4" variable="SpecularPower" default="(1.0, 1.0, 1.0, 1.0)" />
        <resource type="float3" variable="AmbientAccum" default="(0.0, 0.0, 0.0)" />
        <resource type="float3" variable="DiffuseAccum" default="(0.0, 0.0, 0.0)" />
        <resource type="float3" variable="SpecularAccum" default="(0.0, 0.0, 0.0)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="AmbientAccumOut" />
        <resource type="float3" variable="DiffuseAccumOut" />
        <resource type="float3" variable="SpecularAccumOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    // Get the world space light vector.
    float3 LightVector;
    float DistanceToLight;
    float DistanceToLightSquared;
        
    if (LightType == 0)
    {
        LightVector = -LightDirection;
    }
    else
    {
        LightVector = LightPos - WorldPos;
        DistanceToLightSquared = dot(LightVector, LightVector);
        DistanceToLight = length(LightVector);
        LightVector = normalize(LightVector);
    }
    
    // Take N dot L as intensity.
    float LightNDotL = dot(LightVector, WorldNrm);
    float LightIntensity = max(0, LightNDotL);

    float Attenuate = Shadow;
    
    if (LightType != 0)
    {
        // Attenuate Here
        Attenuate = LightAttenuation.x + LightAttenuation.y * DistanceToLight + LightAttenuation.z * DistanceToLightSquared;
        Attenuate = max(1.0, Attenuate);
        Attenuate = 1.0 / Attenuate;
        Attenuate *= Shadow;

        if (LightType == 2)
        {
            // Get intensity as cosine of light vector and direction.
            float CosAlpha = dot(-LightVector, LightDirection);

            // Factor in inner and outer cone angles.
            CosAlpha = saturate((CosAlpha - LightSpotAttenuation.y) / (LightSpotAttenuation.x - LightSpotAttenuation.y));

            // Power to falloff.
            // The pow() here can create a NaN if CosAlpha is 0 or less.
            // On some cards (GeForce 6800), the NaN will propagate through
            // a ternary instruction, so we need two to be safe.
            float origCosAlpha = CosAlpha;
            CosAlpha = origCosAlpha &lt;= 0.0 ? 1.0 : CosAlpha;
            CosAlpha = pow(CosAlpha, LightSpotAttenuation.z);
            CosAlpha = origCosAlpha &lt;= 0.0 ? 0.0 : CosAlpha;

            // Multiply the spot attenuation into the overall attenuation.
            Attenuate *= CosAlpha;
        }

    }
    // Determine the interaction of diffuse color of light and material.
    // Scale by the attenuated intensity.
    DiffuseAccumOut = DiffuseAccum;
    DiffuseAccumOut.rgb += LightDiffuse.rgb * LightIntensity * Attenuate;

    // Determine ambient contribution - Is affected by shadow
    AmbientAccumOut = AmbientAccum;
    AmbientAccumOut.rgb += LightAmbient.rgb * Attenuate;

    SpecularAccumOut = SpecularAccum;
    if (SpecularEnable)
    {
        // Get the half vector.
        float3 LightHalfVector = LightVector + WorldViewVector;
        LightHalfVector = normalize(LightHalfVector);

        // Determine specular intensity.
        float LightNDotH = max(0.00001f, dot(WorldNrm, LightHalfVector));
        float LightSpecIntensity = pow(LightNDotH, SpecularPower.x);
        
        //if (LightNDotL &lt; 0.0)
        //	LightSpecIntensity = 0.0;
        // Must use the code below rather than code above.
        // Using previous lines will cause the compiler to generate incorrect
        // output.
        float SpecularMultiplier = LightNDotL &gt; 0.0 ? 1.0 : 0.0;
        
        // Attenuate Here
        LightSpecIntensity = LightSpecIntensity * Attenuate * 
            SpecularMultiplier;
        
        // Determine the interaction of specular color of light and material.
        // Scale by the attenuated intensity.
        SpecularAccumOut.rgb += LightSpecIntensity * LightSpecular;
    }
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="ApplyFog">
    <desc>
    This fragment is responsible for applying the fog based on the 
    calculations in the vertex shader.
    
    </desc>
    <inputs>
        <resource type="float3" variable="UnfoggedColor" default="(0.0, 0.0, 0.0)" />
        <resource type="float3" variable="FogColor" default="(0.0, 0.0, 0.0)" />
        <resource type="float" variable="FogAmount" default="(1.0)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="FoggedColor" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    FoggedColor = lerp(FogColor, UnfoggedColor, FogAmount);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex" name="ApplyAlphaTest">
    <desc>
    This fragment is responsible for alpha testing based on the alpha
    reference value and alpha test function.
    </desc>
    <inputs>
        <resource type="float" variable="AlphaTestValue" default="(1.0)" />
        <resource type="float3" variable="AlphaTestFunction" default="(0.0, 0.0, 0.0)" />
        <resource type="float" variable="AlphaTestRef" default="(0.0)" />
    </inputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="ps_2_0/ps_4_0">
    // These tests will evaluate to less than 0 if they are true.
    float fLessTest = (AlphaTestValue - AlphaTestRef);
    float fGreaterTest = -fLessTest;
    float fEqualTest = 0.0;
    if (fLessTest == 0.0)
        fEqualTest = -1.0;

    // Clip if AlphaTestValue &lt; AlphaTestRef for:
    //  TEST_LESS 
    //  TEST_EQUAL 
    //  TEST_LESSEQUAL 
    clip(fGreaterTest * AlphaTestFunction.x);
    
    // Clip if AlphaTestValue &gt; AlphaTestRef for:
    //  TEST_EQUAL 
    //  TEST_GREATER 
    //  TEST_GREATEREQUAL 
    clip(fLessTest * AlphaTestFunction.y);
    
    // Clip if AlphaTestValue == AlphaTestRef for:
    //  TEST_LESS 
    //  TEST_GREATER 
    //  TEST_NOTEQUAL 
    clip(fEqualTest * AlphaTestFunction.z);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="ComputeShadingCoefficients">
    <desc>
    This fragment is responsible for computing the coefficients for the 
    following equations:
    
    Kdiffuse = MatEmissive + 
        MatAmbient * Summation(0...N){LightAmbientContribution[N]} + 
        MatDiffuse * Summation(0..N){LightDiffuseContribution[N]}
        
    Kspecular = MatSpecular * Summation(0..N){LightSpecularContribution[N]}
    
    </desc>
    <inputs>
        <resource type="float3" variable="MatEmissive" default="(0.0, 0.0, 0.0)" />
        <resource type="float3" variable="MatDiffuse" default="(0.0, 0.0, 0.0)" />
        <resource type="float3" variable="MatAmbient" default="(0.0, 0.0, 0.0)" />
        <resource type="float3" variable="MatSpecular" default="(0.0, 0.0, 0.0)" />
        <resource type="float3" variable="LightSpecularAccum" default="(0.0, 0.0, 0.0)" />
        <resource type="float3" variable="LightDiffuseAccum" default="(0.0, 0.0, 0.0)" />
        <resource type="float3" variable="LightAmbientAccum" default="(0.0, 0.0, 0.0)" />
        <resource type="bool" variable="Saturate" default="(true)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Diffuse" />
        <resource type="float3" variable="Specular" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Diffuse = MatEmissive + MatAmbient * LightAmbientAccum + MatDiffuse * LightDiffuseAccum;
    Specular = MatSpecular * LightSpecularAccum;
    
    if (Saturate)
    {
        Diffuse = saturate(Diffuse);
        Specular = saturate(Specular);
    }
    </code>
</fragment>

<!--========================================================================-->
<fragment type="Pixel/Vertex" name="SplitColorAndOpacity">
    <desc>
    Separate a float4 into a float3 and a float.   
    </desc>
    <inputs>
        <resource type="float4" variable="ColorAndOpacity" default="(1.0, 1.0, 1.0, 1.0)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Color" />
        <resource type="float" variable="Opacity" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Color.rgb = ColorAndOpacity.rgb;
    Opacity = ColorAndOpacity.a;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="SplitRGBA">
    <desc>
    Separate a float4 into 4 floats.   
    </desc>
    <inputs>
        <resource type="float4" variable="ColorAndOpacity" default="(1.0, 1.0, 1.0, 1.0)" />
    </inputs>
    <outputs>
        <resource type="float" variable="Red" />
        <resource type="float" variable="Green" />
        <resource type="float" variable="Blue" />
        <resource type="float" variable="Alpha" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Red = ColorAndOpacity.r;
    Green = ColorAndOpacity.g;
    Blue = ColorAndOpacity.b;
    Alpha = ColorAndOpacity.a;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="CompositeFinalRGBColor">
    <desc>
    This fragment is responsible for computing the final RGB color.
    </desc>
    <inputs>
        <resource type="float3" variable="DiffuseColor" default="(0.0, 0.0, 0.0)" />
        <resource type="float3" variable="SpecularColor" default="(0.0, 0.0, 0.0)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="OutputColor" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    OutputColor.rgb = DiffuseColor.rgb + SpecularColor.rgb;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="CompositeFinalRGBAColor">
    <desc>
    This fragment is responsible for computing the final RGBA color.
    </desc>
    <inputs>
        <resource type="float3" variable="FinalColor" default="(0.0, 0.0, 0.0)" />
        <resource type="float" variable="FinalOpacity" default="(1.0)" />
    </inputs>
    <outputs>
        <resource type="float4" variable="OutputColor" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    OutputColor.rgb = FinalColor.rgb;
    OutputColor.a = saturate(FinalOpacity);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="AddFloat4">
    <desc>
    This fragment is responsible for adding two float4's. 
    </desc>
    <inputs>
        <resource type="float4" variable="V1" />
        <resource type="float4" variable="V2" />
    </inputs>
    <outputs>
        <resource type="float4" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = V1 + V2;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="AddFloat3">
    <desc>
    This fragment is responsible for adding two float3's. 
    </desc>
    <inputs>
        <resource type="float3" variable="V1" />
        <resource type="float3" variable="V2" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = V1 + V2;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="AddFloat2">
    <desc>
    This fragment is responsible for adding two float2's. 
    </desc>
    <inputs>
        <resource type="float2" variable="V1" />
        <resource type="float2" variable="V2" />
    </inputs>
    <outputs>
        <resource type="float2" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = V1 + V2;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="AddFloat">
    <desc>
    This fragment is responsible for adding two floats. 
    </desc>
    <inputs>
        <resource type="float" variable="V1" />
        <resource type="float" variable="V2" />
    </inputs>
    <outputs>
        <resource type="float" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = V1 + V2;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="MultiplyFloat4">
    <desc>
    This fragment is responsible for multiplying two float4's. 
    </desc>
    <inputs>
        <resource type="float4" variable="V1" />
        <resource type="float4" variable="V2" />
    </inputs>
    <outputs>
        <resource type="float4" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = V1 * V2;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="MultiplyFloat3">
    <desc>
    This fragment is responsible for multiplying two float3's. 
    </desc>
    <inputs>
        <resource type="float3" variable="V1" />
        <resource type="float3" variable="V2" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = V1 * V2;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="MultiplyFloat2">
    <desc>
    This fragment is responsible for multiplying two float2's. 
    </desc>
    <inputs>
        <resource type="float2" variable="V1" />
        <resource type="float2" variable="V2" />
    </inputs>
    <outputs>
        <resource type="float2" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = V1 * V2;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="MultiplyFloat">
    <desc>
    This fragment is responsible for multiplying two floats. 
    </desc>
    <inputs>
        <resource type="float" variable="V1" />
        <resource type="float" variable="V2" />
    </inputs>
    <outputs>
        <resource type="float" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = V1 * V2;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="ScaleFloat4">
    <desc>
    This fragment is responsible for scaling a float4 by a constant. 
    </desc>
    <inputs>
        <resource type="float4" variable="V1" />
        <resource type="float" variable="Scale" />
    </inputs>
    <outputs>
        <resource type="float4" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = Scale * V1;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="ScaleFloat3">
    <desc>    
    This fragment is responsible for scaling a float3 by a constant. 
    </desc>
    <inputs>
        <resource type="float3" variable="V1" />
        <resource type="float" variable="Scale" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = Scale * V1;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="ScaleFloat2">
    <desc>
    This fragment is responsible for scaling a float2 by a constant. 
    </desc>
    <inputs>
        <resource type="float2" variable="V1" />
        <resource type="float" variable="Scale" />
    </inputs>
    <outputs>
        <resource type="float2" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = Scale * V1;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="SaturateFloat4">
    <desc>
    This fragment is responsible for saturating a float4. 
    </desc>
    <inputs>
        <resource type="float4" variable="V1" />
    </inputs>
    <outputs>
        <resource type="float4" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = saturate(V1);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="SaturateFloat3">
    <desc>
    This fragment is responsible for saturating a float3. 
    </desc>
    <inputs>
        <resource type="float3" variable="V1" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = saturate(V1);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="SaturateFloat2">
    <desc>
    This fragment is responsible for saturating a float2. 
    </desc>
    <inputs>
        <resource type="float2" variable="V1" />
    </inputs>
    <outputs>
        <resource type="float2" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = saturate(V1);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="SaturateFloat">
    <desc>
    This fragment is responsible for saturating a float. 
    </desc>
    <inputs>
        <resource type="float" variable="V1" />
    </inputs>
    <outputs>
        <resource type="float" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = saturate(V1);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="LerpFloat4">
    <desc>
    This fragment is responsible for linearly interpolating two float4's. 
    </desc>
    <inputs>
        <resource type="float4" variable="V1" />
        <resource type="float4" variable="V2" />
        <resource type="float" variable="LerpAmount" default="(0.5)" />
    </inputs>
    <outputs>
        <resource type="float4" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = lerp(V1, V2, LerpAmount);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="LerpFloat3">
    <desc>
    This fragment is responsible for linearly interpolating two float3's. 
    </desc>
    <inputs>
        <resource type="float3" variable="V1" />
        <resource type="float3" variable="V2" />
        <resource type="float" variable="LerpAmount" default="(0.5)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = lerp(V1, V2, LerpAmount);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="LerpFloat2">
    <desc>
    This fragment is responsible for linearly interpolating two float2's.   
    </desc>
    <inputs>
        <resource type="float2" variable="V1" />
        <resource type="float2" variable="V2" />
        <resource type="float" variable="LerpAmount" default="(0.5)" />
    </inputs>
    <outputs>
        <resource type="float2" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = lerp(V1, V2, LerpAmount);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel/Vertex" name="LerpFloat">
    <desc>
    This fragment is responsible for linearly interpolating two floats.   
    </desc>
    <inputs>
        <resource type="float" variable="V1" />
        <resource type="float" variable="V2" />
        <resource type="float" variable="LerpAmount" default="(0.5)" />
    </inputs>
    <outputs>
        <resource type="float" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = lerp(V1, V2, LerpAmount);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="NormalizeFloat4">
    <desc>
    This fragment is responsible for normalizing a float4.
    </desc>
    <inputs>
        <resource type="float4" variable="VectorIn" />
    </inputs>
    <outputs>
        <resource type="float4" variable="VectorOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    VectorOut = normalize(VectorIn);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="NormalizeFloat3">
    <desc>
    This fragment is responsible for normalizing a float3.
    </desc>
    <inputs>
        <resource type="float3" variable="VectorIn" />
    </inputs>
    <outputs>
        <resource type="float3" variable="VectorOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    VectorOut = normalize(VectorIn);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="NormalizeFloat2">
    <desc>
    This fragment is responsible for normalizing a float2.
    </desc>
    <inputs>
        <resource type="float2" variable="VectorIn" />
    </inputs>
    <outputs>
        <resource type="float2" variable="VectorOut" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    VectorOut = normalize(VectorIn);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Pixel" name="MultiplyScalarSatAddFloat3">
    <desc>
    This fragment is responsible for accumulating into the current color by
    multiplying the sampled texture color with the current color. The 
    original input alpha channel is preserved. The scalar value is added to the
    sampled color value and then clamped to the range [0.0, 1.0].
    </desc>
    <inputs>
        <resource type="float3" variable="V1" default="(1.0, 1.0, 1.0)" />
        <resource type="float3" variable="V2" default="(1.0, 1.0, 1.0)" />
        <resource type="float" variable="Scalar" default="(0.0)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = V1 * saturate(V2.rgb + Scalar.rrr);
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="MultiplyAddFloat3">
    <desc>
    This fragment implements the equation:
    Output = (V1 * V2) + V3
    </desc>
    <inputs>
        <resource type="float3" variable="V1" default="(1.0, 1.0, 1.0)" />
        <resource type="float3" variable="V2" default="(1.0, 1.0, 1.0)" />
        <resource type="float3" variable="V3" default="(1.0, 1.0, 1.0)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = (V1 * V2) + V3;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="FloatToFloat3">
    <desc>
    This fragment implements the operation:
    Output = float3(Input, Input, Input);
    </desc>
    <inputs>
        <resource type="float" variable="Input" default="(1.0)" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = Input.rrr;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="FloatToFloat4">
    <desc>
    This fragment implements the operation:
    Output = float4(Input, Input, Input, Input);
    </desc>
    <inputs>
        <resource type="float" variable="Input" default="(1.0)" />
    </inputs>
    <outputs>
        <resource type="float4" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = Input.rrrr;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="Float4ToFloat">
    <desc>
    This fragment implements the operation:
    Output = Input.r;
    </desc>
    <inputs>
        <resource type="float4" variable="Input" default="(1.0, 1.0, 1.0, 1.0)" />
    </inputs>
    <outputs>
        <resource type="float" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = Input.r;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="Float3ToFloat">
    <desc>
    This fragment implements the operation:
    Output = Input.r;
    </desc>
    <inputs>
        <resource type="float3" variable="Input" default="(1.0, 1.0, 1.0, 1.0)" />
    </inputs>
    <outputs>
        <resource type="float" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = Input.r;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Vertex/Pixel" name="ConstructInstanceTransform">
    <desc>
    This fragment is reponsible for creating the world-instance transform.
    This is a 4x4 transform that is constructed from 3 float4 objects. It 
    assumes the the last column in the matrix should be (0, 0, 0, 1).
    </desc>
    <inputs>
        <resource type="float4" variable="Position1" />
        <resource type="float4" variable="Position2" />
        <resource type="float4" variable="Position3" />
    </inputs>
    <outputs>
        <resource type="float4x4" variable="InstanceWorld" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/vs_4_0">
    // Build instance world transform matrix.
    InstanceWorld._11 = Position1.x;
    InstanceWorld._12 = Position1.y;
    InstanceWorld._13 = Position1.z;
    InstanceWorld._14 = 0;

    InstanceWorld._21 = Position2.x;
    InstanceWorld._22 = Position2.y;
    InstanceWorld._23 = Position2.z;
    InstanceWorld._24 = 0;

    InstanceWorld._31 = Position3.x;
    InstanceWorld._32 = Position3.y;
    InstanceWorld._33 = Position3.z;
    InstanceWorld._34 = 0;

    InstanceWorld._41 = Position1.w;
    InstanceWorld._42 = Position2.w;
    InstanceWorld._43 = Position3.w;
    InstanceWorld._44 = 1;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Hull" name="Flat_PatchConstantFunc">
    <desc>
    </desc>
    <inputs>
        <resource type="InputPatch&lt;Patch, 3&gt;" variable="I" />
    </inputs>
    <outputs>
        <resource type="float" semantic="SV_TessFactor" variable="TessFactor" count="3" />
        <resource type="float" semantic="SV_InsideTessFactor" variable="InsideTessFactor" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11" target="hs_5_0">
    float4 TessFactors;
    PatchAdaptiveFunction(I, TessFactors);

    TessFactor[0] = TessFactors.x;
    TessFactor[1] = TessFactors.y;
    TessFactor[2] = TessFactors.z;
    InsideTessFactor = TessFactors.w;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Hull" name="PNTriangles_PatchConstantFunc">
    <desc>
    </desc>
    <inputs>
        <resource type="InputPatch&lt;Patch, 3&gt;" variable="I" />
    </inputs>
    <outputs>
        <resource type="float3" semantic="Position3" variable="B210" />
        <resource type="float3" semantic="Position4" variable="B120" />
        <resource type="float3" semantic="Position5" variable="B021" />
        <resource type="float3" semantic="Position6" variable="B012" />
        <resource type="float3" semantic="Position7" variable="B102" />
        <resource type="float3" semantic="Position8" variable="B201" />
        <resource type="float3" semantic="Center" variable="B111" />
        <resource type="float3" semantic="Normal3" variable="N110" />
        <resource type="float3" semantic="Normal4" variable="N011" />
        <resource type="float3" semantic="Normal5" variable="N101" />
        <resource type="float" semantic="SV_TessFactor" variable="TessFactor" count="3" />
        <resource type="float" semantic="SV_InsideTessFactor" variable="InsideTessFactor" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11" target="hs_5_0">
    float4 TessFactors;
    PatchAdaptiveFunction(I, TessFactors);

    TessFactor[0] = TessFactors.x;
    TessFactor[1] = TessFactors.y;
    TessFactor[2] = TessFactors.z;
    InsideTessFactor = TessFactors.w;

    // Now setup the PNTriangle control points...

    // Assign Positions
    float3 B003 = I[0].Position;
    float3 B030 = I[1].Position;
    float3 B300 = I[2].Position;

    // And Normals
    float3 N002 = I[0].Normal;
    float3 N020 = I[1].Normal;
    float3 N200 = I[2].Normal;

    // Compute the cubic geometry control points
    // Edge control points
    B210 = ((2.0 * B003) + B030 - (dot((B030 - B003), N002) * N002)) / 3.0;
    B120 = ((2.0 * B030) + B003 - (dot((B003 - B030), N020) * N020)) / 3.0;
    B021 = ((2.0 * B030) + B300 - (dot((B300 - B030), N020) * N020)) / 3.0;
    B012 = ((2.0 * B300) + B030 - (dot((B030 - B300), N200) * N200)) / 3.0;
    B102 = ((2.0 * B300) + B003 - (dot((B003 - B300), N200) * N200)) / 3.0;
    B201 = ((2.0 * B003) + B300 - (dot((B300 - B003), N002) * N002)) / 3.0;

    // Center control point
    float3 E = (B210 + B120 + B021 + B012 + B102 + B201) / 6.0;
    float3 V = (B003 + B030 + B300) / 3.0;
    B111 = E + ((E - V) / 2.0);

    // Compute the quadratic normal control points, and rotate into world space
    float V12 = 2.0 * dot(B030 - B003, N002 + N020) / dot(B030 - B003, B030 - B003);
    float V23 = 2.0 * dot(B300 - B030, N020 + N200) / dot(B300 - B030, B300 - B030);
    float V31 = 2.0 * dot(B003 - B300, N200 + N002) / dot(B003 - B300, B003 - B300);
    N110 = normalize(N002 + N020 - V12 * (B030 - B003));
    N011 = normalize(N020 + N200 - V23 * (B300 - B030));
    N101 = normalize(N200 + N002 - V31 * (B003 - B300));
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Domain" name="Project">
    <desc>
    </desc>
    <inputs>
        <resource type="float3" variable="Input1" />
        <resource type="float3" variable="Input2" />
        <resource type="float3" variable="Input3" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    Output = Input1 - dot(Input1 - Input2, Input3) * Input3;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Domain" name="Linear">
    <desc>
    </desc>
    <inputs>
        <resource type="float3" variable="Input1" />
        <resource type="float3" variable="Input2" />
        <resource type="float3" variable="Input3" />
        <resource type="float3" variable="Weight" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    float U = Weight.x;
    float V = Weight.y;
    float W = Weight.z;

    Output = Input1 * W;
    Output += Input2 * U;
    Output += Input3 * V;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Domain" name="BaryCentric">
    <desc>
    </desc>
    <inputs>
        <resource type="float3" variable="Input1" />
        <resource type="float3" variable="Input2" />
        <resource type="float3" variable="Input3" />
        <resource type="float3" variable="Control221" />
        <resource type="float3" variable="Control122" />
        <resource type="float3" variable="Control212" />
        <resource type="float3" variable="Weight" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    // The barycentric coordinates
    float U = Weight.x;
    float V = Weight.y;
    float W = Weight.z;

    // Precompute squares and squares * 3
    float UU = U * U;
    float VV = V * V;
    float WW = W * W;

    Output = Input1 * WW;
    Output += Input2 * UU;
    Output += Input3 * VV;
    Output += Control221 * W * U;
    Output += Control122 * U * V;
    Output += Control212 * V * W;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Domain" name="BaryCentric2">
    <desc>
    </desc>
    <inputs>
        <resource type="float3" variable="Input1" />
        <resource type="float3" variable="Input2" />
        <resource type="float3" variable="Input3" />
        <resource type="float3" variable="Control321" />
        <resource type="float3" variable="Control231" />
        <resource type="float3" variable="Control312" />
        <resource type="float3" variable="Control132" />
        <resource type="float3" variable="Control213" />
        <resource type="float3" variable="Control123" />
        <resource type="float3" variable="Control222" />
        <resource type="float3" variable="Weight" />
    </inputs>
    <outputs>
        <resource type="float3" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11/D3D10/DX9/Xenon/PS3" target="vs_1_1/ps_2_0/vs_4_0/gs_4_0/ps_4_0/hs_5_0/ds_5_0">
    // The barycentric coordinates
    float U = Weight.x;
    float V = Weight.y;
    float W = Weight.z;

    // Precompute squares and squares * 3
    float UU = U * U;
    float VV = V * V;
    float WW = W * W;
    float UU3 = UU * 3.0;
    float VV3 = VV * 3.0;
    float WW3 = WW * 3.0;
    float UVW6 = U * V * W * 6.0;

    Output = Input1 * WW * W;
    Output += Input2 * UU * U;
    Output += Input3 * VV * V;
    Output += Control321 * WW3 * U;
    Output += Control231 * W * UU3;
    Output += Control312 * WW3 * V;
    Output += Control132 * UU3 * V;
    Output += Control213 * W * VV3;
    Output += Control123 * U * VV3;
    Output += Control222 * UVW6;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Hull" name="DefaultPatchAdaptiveFunction">
    <desc>
    </desc>
    <inputs>
        <resource type="InputPatch&lt;Patch, 3&gt;" variable="I" />
    </inputs>
    <outputs>
        <resource type="float4" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11" target="hs_5_0">
    Output = g_TessFactor.xxxy;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Hull" name="ScreenSpacePatchAdaptiveFunction">
    <desc>
    </desc>
    <inputs>
        <resource type="InputPatch&lt;Patch, 3&gt;" variable="I" />
    </inputs>
    <outputs>
        <resource type="float4" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11" target="hs_5_0">
    Output = g_TessFactor.xxxy;

    float4 P1 = mul(float4(I[0].Position, 1.0), g_ViewProj);
    float4 P2 = mul(float4(I[1].Position, 1.0), g_ViewProj);
    float4 P3 = mul(float4(I[2].Position, 1.0), g_ViewProj);

    float2 B1 = P1.xy / P1.w;
    float2 B2 = P2.xy / P2.w;
    float2 B3 = P3.xy / P3.w;

    B1 = (B1 + 1.0) * 0.5 * g_ScreenSize.xy;
    B2 = (B2 + 1.0) * 0.5 * g_ScreenSize.xy;
    B3 = (B3 + 1.0) * 0.5 * g_ScreenSize.xy;

    float EdgeScreenLength;
    float TargetTessFactor;
    float Scale;
    float EdgeSize = 16.0;

    EdgeScreenLength = distance(B3, B1);
    TargetTessFactor = EdgeScreenLength / g_TessFactor.x / EdgeSize;
    Scale = saturate(TargetTessFactor);
    Output.x = lerp(0.0, Output.x, Scale);

    EdgeScreenLength = distance(B1, B2);
    TargetTessFactor = EdgeScreenLength / g_TessFactor.x / EdgeSize;
    Scale = saturate(TargetTessFactor);
    Output.y = lerp(0.0, Output.y, Scale);

    EdgeScreenLength = distance(B2, B3);
    TargetTessFactor = EdgeScreenLength / g_TessFactor.x / EdgeSize;
    Scale = saturate(TargetTessFactor);
    Output.z = lerp(0.0, Output.z, Scale);

    Output.w = (Output.x + Output.y + Output.z) / 3.0;
    </code>
</fragment>
<!--========================================================================-->
<fragment type="Hull" name="DistancePatchAdaptiveFunction">
    <desc>
    </desc>
    <inputs>
        <resource type="InputPatch&lt;Patch, 3&gt;" variable="I" />
    </inputs>
    <outputs>
        <resource type="float4" variable="Output" />
    </outputs>
    <code lang="hlsl/Cg" platform="D3D11" target="hs_5_0">
    Output = g_TessFactor.xxxy;

    float3 MidPoint;
    float Distance;
    float Scale;

    MidPoint = (I[2].Position + I[0].Position) * 0.5;
    Distance = distance(MidPoint, g_EyePos) - g_TessFactor.z;
    Scale = saturate(Distance / g_TessFactor.w);
    Output.x = lerp(Output.x, 1.0, Scale);

    MidPoint = (I[0].Position + I[1].Position) * 0.5;
    Distance = distance(MidPoint, g_EyePos) - g_TessFactor.z;
    Scale = saturate(Distance / g_TessFactor.w);
    Output.y = lerp(Output.y, 1.0, Scale);

    MidPoint = (I[1].Position + I[2].Position) * 0.5;
    Distance = distance(MidPoint, g_EyePos) - g_TessFactor.z;
    Scale = saturate(Distance / g_TessFactor.w);
    Output.z = lerp(Output.z, 1.0, Scale);

    Output.w = (Output.x + Output.y + Output.z) / 3.0;
    </code>
</fragment>
<!--========================================================================-->
</library>
